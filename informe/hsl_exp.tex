\section*{HSL: Experimentación}

La principal limitación de nuestra implementación de assembler son, claramente, los accesos a memoria. En cada rutina (de ambas implementaciones) debemos cargar muchas constantes que usaremos a lo largo de las distintas cuentas que debemos hacer.
Esto es muy caro para nosotros, dado que los accesos a memoria son de lo mas limitante en lo que concierne a la performance. 
A esto atribuimos principalmente nuiestro pobre desemopeño frente a la implementacion de C.

De hecho por esa razón alineamos nuestras constantes que usamos todo el tiempo, buscando una ganancia en performance que efectivamente logramos.

GRAFICO QUE MUESTRA LA GANANCIA DE PERFORMANCE ALINEADO VS DESALINEADO

Nuestros algoritmos no dependen fuertemente en saltos condicionales, usan los necesarios, por lo tanto no creemos que este sea un factor limitante del rendimiento.
\\

La siguiente limitación de nuestra implementación es la operatoria de las conversiones de RGB a HSL y viceversa. Esto se debe a que las operaciones que se deben hacer son largas y costosas, por mas que esten lo mejor optimizadas posibles.

A esto se le suma la dificultad de operar de a muchos píxeles juntos, dado que solo se puede en pequeñas partes.
Por ejemplo, en hslTOrgb se podría calcular de forma paralela c, x, m para 4 pixeles así como la operatoria de los shuffles.
Sin embargo, la complejidad del código crece enormemente, sumado a que la operación de rgbTOhsl y la de Suma no son así de simples de paralelizar.
Por estas razones, optamos por no probar esta variante del código, pero es una opción a tener encuenta
\\

Una variante que sí implementamos fue la de utilizar shifts en vez de shuffles. De hecho esta fue nuestra primera implementación del código, dado que era más simple y despues decidimos pasarla a shuffles cuando en clase vimos que daba una mejora de la performance. Por esta razón nos pareció interesante comprobar empiricamente esto que nos fue dicho en clase.

GRAFICO DE ACCESO ALINEADO VS DESALINEADO






