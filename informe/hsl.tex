\section{HSL}

\subsection{C}
El código de C, al igual que el resto, es bastante sencillo. Lo que hace es loopear sobre todos los píxeles, hacer una conversión de RGB a HSL, hacer las sumas correspondientes, y luego volver a convertir a RGB.

Lo malo de la implementacion es que el código sin optimizar de C hace más operaciones de las necesarias, ya que no usa todo el poder de las operaciones en SSE, que nosotros intentamos utilizar al máximo.

\subsection{ASM1}

En la versión primera versión del código de assembler la operatoriaes bastante distinta a la de C.
Al principio calculamos en xmm4 el vector de números que debemos sumarle a cada pixel hsl, con los parámetros que nos pasaron. De esta manera, 

\xmm{4}
\regfloats{l}{s}{h}{0}

Donde h,s,l son los que nos pasaron como parámetro y el 0 es lo que le tenemos que sumar a la transparencia (nada). Este registro tenemos que guardarlo en la pila, dado que cuando llamamos a rgbTOhsl, nos puede pisar los registros xmm pues la calling convention de C no especifica nada sobre que no se puedan pisar (de hecho en algunos casos lo pisa, fue un bug que tardamos en encontrar).

Tambien tenemos que malloc'ear un float para llamar a las funciones rgbTOhsl y hslTOrgb. Podríamos usar la pila, pero nos resultó mas fácil usar este método.

Luego comenzamos a loopear. 

Luego de convertir el pixel en cuestión de rgb a hsl, vamos a tener su valor en \xmm{3}.

\xmm{3}
\regfloats{LL}{SS}{HH}{AA}

Luego sumamos este registro con el registro que contiene los parámetros, como indica el filtro, de manera que queda

\xmm{3}
\regfloats{l+LL}{s+SS}{h+HH}{AA}

Va a ser útil para mas adelante tener un ejemplo, así que supongamos que \xmm{3} vale

\xmm{3}
\regfloats{0.5}{-0.322}{380}{255}


Ahora comienza la operatoria de saturación, entonces vamos a armar los siguientes registros

\xmm{5}
\regfloats{1-(l+LL)}{1-(s+SS)}{-360}{0}

\xmm{6}
\regfloats{-(l+LL)}{-(s+SS)}{360}{0}

Siguiendo el ejemplo anterior, los registros quedarían

\xmm{5}
\regfloats{0.5}{1.322}{-360}{0}

\xmm{6}
\regfloats{-0.5}{0.322}{360}{0}



Entonces procedemos a formar estos registros, usando la menor cantidad de instrucciones posibles, como siempre.

Luego nos armamos 2 registros más, que vamos a usar para las comparaciones

\xmm{12}
\regfloats{1}{1}{360}{256}

\xmm{13}
\regfloats{0}{0}{0}{0}


Luego comparamos estos registros con nuestro registro \xmm{3} (nótese que como SSE carece de comparaciones de mayor o igual, hay que dar vuelta los registros y hacer una comparacion de menor o igual).

Por lo tanto, con el ejemplo anterior, \xmm{12} y \xmm{13} quedan así:

\xmm{12}
\regfloats{0h}{0h}{ffffffffh}{0h}

\xmm{13}
\regfloats{0h}{ffffffffh}{0h}{0h}


Luego les hacemos un and entre los registros \xmm{12} y \xmm{5} y entre \xmm{13} y \xmm{6}, dword a dword, de manera seleccionar lo que vamos a querer sumar. En el ejemplo esto queda


\xmm{5}
\regfloats{0}{0}{-360}{0}

\xmm{6}
\regfloats{0}{0.322}{0}{0}

Recordemos el valor de \xmm{3}

\xmm{3}
\regfloats{0.5}{-0.322}{380}{255}


Ahora les sumamos estos registros a \xmm{3}, para terminar de llevar a cabo nuestro plan

\xmm{3}
\regfloats{0.5}{0}{320}{255}

Y listo, todo terminó como queríamos.

Ahora solo falta volver a convertir este numero a RGB y escribirlo a la memoria, de lo que se va a ocupar la funcion hslTOrgb.

