\section{Merge}

\subsection{C}
El código de C es bastante simple. Lo que hace al inicio es castear ambos punteros a punteros a matrices de matrices, que tienen elementos de w bytes de tamaño, que a su vez tienen elementos de 4 bytes de tamaño.

Luego se realizan 3 loops, el primero sobre las filas, el segundo sobre las columnas, y el tercero sobre los canales (exceptuando el canal de transparencia, notar que ii se inicializa en 1).

Finalmente se realiza la cuenta que se debe hacer para hacer el merge, casteando todo adecuadamente (se castea el valor del canal, que es un entero de 1 byte a float, se lo multiplica por value o 1-value segun corresponda, se lo suma con el otro valor y se lo vuelve a castear a entero de 8 bytes).

\subsection{ASM1}

En la primera versión del codigo de ASM, iniciamos guardando los parámetros que nos pasan en algunos registros auxiliares para no perderlos mas adelante.
Luego calculamos h*w dado que es la cantidad de iteraciones que vamos a realizar.

En el loop lo que hacemos es tener dos vectores de floats

\xmm{3}
\regfloats{$value$}{$value$}{$value$}{$1.0$}

\xmm{4}
\regfloats{$1-value$}{$1-value$}{$1-value$}{$0.0$}

Y levantamos de a un pixel, cuyos canales convertimos a float y multiplicamos por los registros exhibidos anteriormente. Luego convertimos a enteros de 8 bits nuevamente, packeando.

Notar que no se produce overflow. Tomemos por ejemplo el canal R, y supongamos que el valor del canal R para ambas imágenes es $255$.
Entonces $255value + 255(1-value)$ da $255$, que entra en 8 bits (si por errores de redondeo diera más, no importa, ya que el packing lo hacemos saturado, entonces se queda en 255).

Finalmente escribimos en el lugar de la memoria correspondiente el valor obtenido y listo, repetimos este proceso hasta terminar.
\\

Aunque algoritmicamente esta rutina es exactamente igual a la de C, esperamos que tenga mejor rendimiento por dos razones.
Primero, en esta rutina tenemos que hacer menos saltos, dado que solo tenemos un loop, mientras que la version de C tiene 2 loops.
Segundo, porque si el compilador no optimiza a la perfeccion las operaciones, es muy probable que realice las operaciones de los canales en serie, en vez de como lo hacemos nosotros, en paralelo.
Es decir, en el código de C los canales se van a procesar uno detras del otro, mientras que en nuestro código se van a procesar todos juntos.


\subsection{ASM2}

Al igual que en la rutina anterior, luego de armar el stackframe guardamos los parametros en algunos registros auxiliares para no perderlos. El resto del proceso es el mismo que antes, hasta que llegamos al precalculo de los vectores de $value$. Como aquí hay que hacer operaciones con enteros, en vez de punto flotante como antes, vamos a calcular las cosas de manera diferente.

En vez de guardarnos $value$, vamos a guardarnos $int16(256*value)$. ¿Por qué? Porque de esta manera vamos a poder cargar de a dos pixeles y hacer las operaciones mucho mas rápido que antes. Además así guardamos un valor que antes estaba entre 0 y 1 en un valor que esta entre 0 y 256, es decir, un valor que podemos representar con una buena aproximación entera.

De esta menera nos armamos el vector igual que antes, solo que multiplicado por 256. Luego lo pasamos a entero y luego lo packeamos consigo mismo en la parte alta.

De esta manera obtenemos en \xmm{3} los siguientes valores

\xmm{3}

\regintOcho{256$v$}{256$v$}{256$v$}{256}{256$v$}{256$v$}{256$v$}{256}

Donde $v$ es $value$.


Ahora, nos gustaría tener en el otro registros los numeros tal que, sumados con los de \xmm{3}, dan 256. Para eso, nos aprovechamos de la representación complemento a 2, dado que lo que queremos en realidad son los inversos aditivos (en 8 bits) de estos números en el registro \xmm{4}. Entonces usamos que el inverso aditivo de un número es el negado bit a bit más 1.

Cargamos en \xmm{4} 8 enteros de 16 bits con valor 257, ya que es 256+1.
Luego, al hacer la diferencia

\begin{lstlisting}
psubw xmm4, xmm3
\end{lstlisting}

obtenemos en \xmm{4} exactamente lo que queremos, es decir que si sumamos int16 a int16 en \xmm{3} y \xmm{4} da 256.


Luego comenzamos el loop principal, que es muy similar al anterior.
\\

Viendo esta implementación creemos que su desempeño va a ser aún mejor que el de la primera implementación en assembler, dado que hacemos operaciones con números enteros que son mucho más rapidas que las operaciones con punto flotante. Sin embargo, hacer operaciones con números enteros implica un trade-off de velocidad por precisión, aunque el código es mucho mas rápido tambien es (muy poco) más inexacto. Analizaremos este error a continuación.

\subsubsection*{Error}

En la segunda versión de merge se comete, obviamente, más error que en la primera, dado que estamos trabajando con enteros, debemos perder precision cuando convertimos $256v$ a entero.

Por esta razón, aproximadamente el 30\% de las veces, el resultado difiere en más de 2 con el output de C de la catedra. Esto se debe a que los métodos de cómputo son fundamentalmente distintos, uno con mucha mas precision que la otra.

Pese a esto, el 100\% de los tests pasan con un error de 3, es decir, pese a que existe error, es despreciable. El error (por ejemplo, para el canal R) se puede expresar de la siguiente manera

$$\bigg|\lfloor R_1v\rfloor + \lfloor R_2(1-v) \rfloor
  -\bigg\lfloor \frac{R_1\lfloor 256v \rfloor}{256} \bigg\rfloor 
 -\bigg\lfloor \frac{R_2(256- \lfloor 256v) \rfloor)}{256} \bigg\rfloor\bigg| $$


$$\leq
\bigg|
\lfloor R_1v\rfloor - \bigg\lfloor \frac{R_1\lfloor 256v \rfloor}{256} \bigg\rfloor
\bigg|
+
\bigg|
\lfloor R_2(1-v) \rfloor -\bigg\lfloor \frac{R_2(256- \lfloor 256v) \rfloor)}{256} \bigg\rfloor
\bigg| $$

Se puede verificar fácilmente con wolfram-alpha o algún software similar que es es menor que 3.

